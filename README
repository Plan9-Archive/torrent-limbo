# status

in development.  don't expect things to work yet.


# intro

this package contains a bittorrent peer (for downloading and uploading
files), tools for verifying torrents & printing information about
torrents, a bittorrent tracker for use with a http server, and a
program for creating torrent files.


# install

this package depends on "http", "web" and "util".

to install, bind/symlink/include a mkconfig (e.g. from your inferno
install), and:

	mk install

when building from within inferno, insert SYSHOST=Inferno and ROOT=
in the mk invocations to override the values in the mkconfig.


# latest

the latest version can be found at

    http://www.ueber.net/code/r/torrent


# licence & author

all files are in the public domain.  this code has been written by
mechiel lukkien, reachable at mechiel@ueber.net or mechiel@xs4all.nl.


# todo

## wm/torrent: 

- make config options settable.  just put the value in a tk entry, and write+read the new value on return.
- available bar is not smoothly filled
- figure out how to fill the panel with the bars (and thus bars themselves) in x direction
- catch resizes and recreate the bars with new width.
- merge the state & info grids, so they have same widths?
- update grids without redrawing completely?
- make torrent/peer send events on removal of bad peers?  and remove them from our list.  or at least reserve the peerevent message for it.
- clear stale entries from badpeers list.
- limit the history in torrentlog & peerlog.
- could add buttons to peers grid, to disconnect peers.
- availbar seems to pieces with overlap, on the edges of the piece

## torrent/peer

- we need an end-game: request blocks from one piece from multiple peers
- the choking algorithm for uploading should probably use ip pools too?
- for rounds while downloading, shouldn't we ignore seeders when choosing peers to unchoke?
- stopping & starting does not fix up all the state.

- lots of testing
- for unused peers from tracker, make difference between new ip's and known ip's (current peers, bad peers).
- write manual page
- make ctl for max peers, and ratio of dialed/listened peers, and (non)-seeders.
- if we are fully connected, drop some peers once in a while, for better peers/peercloud
- should we set a receive timeout for peers?  in case we expect something (e.g. when we sent requests and are unchoked by remote, but not getting any data for a long time).  probably not worth the trouble.
- should we send keepalives to peers?
- when reading data from local disk for a peer, see if we have to (can) read the entire piece?  not just one block.
- don't try dialing the same peers over and over again.  do some exponential backoff.

- verify hash in separate prog?
- do not block on i/o in peermsg().  should perhaps do more in progs?
- optim: use better data structures in eg Peerbox, so picking peers to unchoke etc doesn't require walking through all the peers and their pieces.
- use numwant in tracker request, set it high
- after having had a peer/seed, but no longer, do a tracker request before interval.  not too often though.
- set max number of peers connected, and max number of seeds among those?
- send keep-alive messages?

- support magnet uri's? (bep 9)
- support fast extensions?  perhaps have all/none messages. (bep 6)
- udp tracker support (bep 15)
- multiple tracker support (bep 12)
- http seeding (bep 17 and/or bep 19)

## torrent/track

- make search for a peer (given ip & port) less inefficient.
- might add scraping.
- might be a bit smarter about which peers to send to a peer.  e.g. not itself, make randomizing cheaper, let peers that are done (left=0) not connect to each other.
